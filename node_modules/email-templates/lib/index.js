'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const path = require('path');
const debug = require('debug')('email-templates');
const fs = require('fs-extra');
const htmlToText = require('html-to-text');
const I18N = require('@ladjs/i18n');
const autoBind = require('auto-bind');
const nodemailer = require('nodemailer');
const consolidate = require('consolidate');
const previewEmail = require('preview-email');
const _ = require('lodash');
const Promise = require('bluebird');

const getPaths = require('get-paths');
const juiceResources = require('juice-resources-promise');

class Email {
  constructor(config = {}) {
    debug('config passed %O', config);

    // 2.x backwards compatible support
    if (config.juiceOptions) {
      config.juiceResources = config.juiceOptions;
      delete config.juiceOptions;
    }
    if (config.disableJuice) {
      config.juice = false;
      delete config.disableJuice;
    }

    this.config = _.merge({
      views: {
        // directory where email templates reside
        root: path.resolve('emails'),
        options: {
          // default file extension for template
          extension: 'pug',
          map: {},
          engineSource: consolidate
        },
        // locals to pass to templates for rendering
        locals: {
          // pretty is automatically set to `false` for subject/text
          pretty: true
        }
      },
      // <https://nodemailer.com/message/>
      message: {},
      send: !['development', 'test'].includes(process.env.NODE_ENV),
      preview: process.env.NODE_ENV === 'development',
      // <https://github.com/ladjs/i18n>
      // set to an object to configure and enable it
      i18n: false,
      // pass a custom render function if necessary
      render: this.render.bind(this),
      // force text-only rendering of template (disregards template folder)
      textOnly: false,
      // <https://github.com/werk85/node-html-to-text>
      htmlToText: {
        ignoreImage: true
      },
      // <https://github.com/Automattic/juice>
      juice: true,
      juiceResources: {
        preserveImportant: true,
        webResources: {
          relativeTo: path.resolve('build')
        }
      },
      // pass a transport configuration object or a transport instance
      // (e.g. an instance is created via `nodemailer.createTransport`)
      // <https://nodemailer.com/transports/>
      transport: {}
    }, config);

    // override existing method
    this.render = this.config.render;

    if (!_.isFunction(this.config.transport.sendMail)) this.config.transport = nodemailer.createTransport(this.config.transport);

    debug('transformed config %O', this.config);

    autoBind(this);
  }

  // shorthand use of `juiceResources` with the config
  // (mainly for custom renders like from a database)
  juiceResources(html) {
    return juiceResources(html, this.config.juiceResources);
  }

  // a simple helper function that gets the actual file path for the template
  getTemplatePath(view) {
    var _this = this;

    return new Promise((() => {
      var _ref = _asyncToGenerator(function* (resolve, reject) {
        try {
          const paths = yield getPaths(_this.config.views.root, view, _this.config.views.options.extension);
          const filePath = path.resolve(_this.config.views.root, paths.rel);
          resolve({ filePath, paths });
        } catch (err) {
          reject(err);
        }
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    })());
  }

  // returns true or false if a template exists
  // (uses same look-up approach as `render` function)
  templateExists(view) {
    var _this2 = this;

    return new Promise((() => {
      var _ref2 = _asyncToGenerator(function* (resolve) {
        try {
          var _ref3 = yield _this2.getTemplatePath(view);

          const filePath = _ref3.filePath;

          const stats = yield fs.stat(filePath);
          if (!stats.isFile()) throw new Error(`${filePath} was not a file`);
          resolve(true);
        } catch (err) {
          debug('templateExists', err);
          resolve(false);
        }
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    })());
  }

  // promise version of consolidate's render
  // inspired by koa-views and re-uses the same config
  // <https://github.com/queckezz/koa-views>
  render(view, locals = {}) {
    var _this3 = this;

    return new Promise((() => {
      var _ref4 = _asyncToGenerator(function* (resolve, reject) {
        try {
          var _config$views$options = _this3.config.views.options;
          const map = _config$views$options.map,
                engineSource = _config$views$options.engineSource;

          var _ref5 = yield _this3.getTemplatePath(view);

          const filePath = _ref5.filePath,
                paths = _ref5.paths;

          if (paths.ext === 'html' && !map) {
            const res = yield fs.readFile(filePath, 'utf8');
            resolve(res);
          } else {
            const engineName = map && map[paths.ext] ? map[paths.ext] : paths.ext;
            const renderFn = engineSource[engineName];
            if (!engineName || !renderFn) return reject(new Error(`Engine not found for the ".${paths.ext}" file extension`));

            if (_.isObject(_this3.config.i18n)) {
              const i18n = new I18N(Object.assign({}, _this3.config.i18n, {
                register: locals
              }));

              // support `locals.user.last_locale`
              // (e.g. for <https://lad.js.org>)
              if (_.isObject(locals.user) && _.isString(locals.user.last_locale)) locals.locale = locals.user.last_locale;

              if (_.isString(locals.locale)) i18n.setLocale(locals.locale);
            }

            // TODO: convert this to a promise based version
            renderFn(filePath, locals, function (err, res) {
              if (err) return reject(err);
              // transform the html with juice using remote paths
              // google now supports media queries
              // https://developers.google.com/gmail/design/reference/supported_css
              if (!_this3.config.juice) return resolve(res);
              _this3.juiceResources(res).then(resolve).catch(reject);
            });
          }
        } catch (err) {
          reject(err);
        }
      });

      return function (_x4, _x5) {
        return _ref4.apply(this, arguments);
      };
    })());
  }

  renderAll(template, locals = {}, message = {}) {
    var _this4 = this;

    return new Promise((() => {
      var _ref6 = _asyncToGenerator(function* (resolve, reject) {
        try {
          let subjectTemplateExists = false;
          let htmlTemplateExists = false;
          let textTemplateExists = false;

          const promises = [_this4.templateExists(`${template}/subject`), _this4.templateExists(`${template}/html`), _this4.templateExists(`${template}/text`)];

          if (template) {
            ;

            var _ref7 = yield Promise.all(promises);

            var _ref8 = _slicedToArray(_ref7, 3);

            subjectTemplateExists = _ref8[0];
            htmlTemplateExists = _ref8[1];
            textTemplateExists = _ref8[2];
          }if (!message.subject && subjectTemplateExists) message.subject = yield _this4.render(`${template}/subject`, Object.assign({}, locals, { pretty: false }));

          if (!message.html && htmlTemplateExists) message.html = yield _this4.render(`${template}/html`, locals);

          if ((!htmlTemplateExists || !_this4.config.htmlToText) && !message.text && textTemplateExists) message.text = yield _this4.render(`${template}/text`, Object.assign({}, locals, { pretty: false }));else if (_this4.config.htmlToText && message.html)
            // we'd use nodemailer-html-to-text plugin
            // but we really don't need to support cid
            // <https://github.com/andris9/nodemailer-html-to-text>
            message.text = htmlToText.fromString(message.html, _this4.config.htmlToText);

          // if we only want a text-based version of the email
          if (_this4.config.textOnly) delete message.html;

          resolve(message);
        } catch (err) {
          reject(err);
        }
      });

      return function (_x6, _x7) {
        return _ref6.apply(this, arguments);
      };
    })());
  }

  send(options = {}) {
    var _this5 = this;

    options = Object.assign({
      template: '',
      message: {},
      locals: {}
    }, options);

    var _options = options;
    let template = _options.template,
        message = _options.message,
        locals = _options.locals;


    const attachments = message.attachments || this.config.message.attachments || [];

    message = _.defaultsDeep({}, _.omit(this.config.message, 'attachments'), _.omit(message, 'attachments'));
    locals = _.defaultsDeep({}, this.config.views.locals, locals);

    if (attachments) message.attachments = attachments;

    debug('template %s', template);
    debug('message %O', message);
    debug('locals (keys only): %O', Object.keys(locals));

    return new Promise((() => {
      var _ref9 = _asyncToGenerator(function* (resolve, reject) {
        try {
          // get all available templates
          const obj = yield _this5.renderAll(template, locals, message);

          // assign the object variables over to the message
          Object.assign(message, obj);

          if (_this5.config.preview) {
            debug('using `preview-email` to preview email');
            yield previewEmail(message);
          }

          if (!_this5.config.send) {
            debug('send disabled so we are ensuring JSONTransport');
            // <https://github.com/nodemailer/nodemailer/issues/798>
            // if (this.config.transport.name !== 'JSONTransport')
            _this5.config.transport = nodemailer.createTransport({
              jsonTransport: true
            });
          }

          const res = yield _this5.config.transport.sendMail(message);
          debug('message sent');
          resolve(res);
        } catch (err) {
          reject(err);
        }
      });

      return function (_x8, _x9) {
        return _ref9.apply(this, arguments);
      };
    })());
  }
}

module.exports = Email;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImRlYnVnIiwiZnMiLCJodG1sVG9UZXh0IiwiSTE4TiIsImF1dG9CaW5kIiwibm9kZW1haWxlciIsImNvbnNvbGlkYXRlIiwicHJldmlld0VtYWlsIiwiXyIsIlByb21pc2UiLCJnZXRQYXRocyIsImp1aWNlUmVzb3VyY2VzIiwiRW1haWwiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImp1aWNlT3B0aW9ucyIsImRpc2FibGVKdWljZSIsImp1aWNlIiwibWVyZ2UiLCJ2aWV3cyIsInJvb3QiLCJyZXNvbHZlIiwib3B0aW9ucyIsImV4dGVuc2lvbiIsIm1hcCIsImVuZ2luZVNvdXJjZSIsImxvY2FscyIsInByZXR0eSIsIm1lc3NhZ2UiLCJzZW5kIiwiaW5jbHVkZXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwcmV2aWV3IiwiaTE4biIsInJlbmRlciIsImJpbmQiLCJ0ZXh0T25seSIsImlnbm9yZUltYWdlIiwicHJlc2VydmVJbXBvcnRhbnQiLCJ3ZWJSZXNvdXJjZXMiLCJyZWxhdGl2ZVRvIiwidHJhbnNwb3J0IiwiaXNGdW5jdGlvbiIsInNlbmRNYWlsIiwiY3JlYXRlVHJhbnNwb3J0IiwiaHRtbCIsImdldFRlbXBsYXRlUGF0aCIsInZpZXciLCJyZWplY3QiLCJwYXRocyIsImZpbGVQYXRoIiwicmVsIiwiZXJyIiwidGVtcGxhdGVFeGlzdHMiLCJzdGF0cyIsInN0YXQiLCJpc0ZpbGUiLCJFcnJvciIsImV4dCIsInJlcyIsInJlYWRGaWxlIiwiZW5naW5lTmFtZSIsInJlbmRlckZuIiwiaXNPYmplY3QiLCJPYmplY3QiLCJhc3NpZ24iLCJyZWdpc3RlciIsInVzZXIiLCJpc1N0cmluZyIsImxhc3RfbG9jYWxlIiwibG9jYWxlIiwic2V0TG9jYWxlIiwidGhlbiIsImNhdGNoIiwicmVuZGVyQWxsIiwidGVtcGxhdGUiLCJzdWJqZWN0VGVtcGxhdGVFeGlzdHMiLCJodG1sVGVtcGxhdGVFeGlzdHMiLCJ0ZXh0VGVtcGxhdGVFeGlzdHMiLCJwcm9taXNlcyIsImFsbCIsInN1YmplY3QiLCJ0ZXh0IiwiZnJvbVN0cmluZyIsImF0dGFjaG1lbnRzIiwiZGVmYXVsdHNEZWVwIiwib21pdCIsImtleXMiLCJvYmoiLCJqc29uVHJhbnNwb3J0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBTUEsT0FBT0MsUUFBUSxNQUFSLENBQWI7QUFDQSxNQUFNQyxRQUFRRCxRQUFRLE9BQVIsRUFBaUIsaUJBQWpCLENBQWQ7QUFDQSxNQUFNRSxLQUFLRixRQUFRLFVBQVIsQ0FBWDtBQUNBLE1BQU1HLGFBQWFILFFBQVEsY0FBUixDQUFuQjtBQUNBLE1BQU1JLE9BQU9KLFFBQVEsYUFBUixDQUFiO0FBQ0EsTUFBTUssV0FBV0wsUUFBUSxXQUFSLENBQWpCO0FBQ0EsTUFBTU0sYUFBYU4sUUFBUSxZQUFSLENBQW5CO0FBQ0EsTUFBTU8sY0FBY1AsUUFBUSxhQUFSLENBQXBCO0FBQ0EsTUFBTVEsZUFBZVIsUUFBUSxlQUFSLENBQXJCO0FBQ0EsTUFBTVMsSUFBSVQsUUFBUSxRQUFSLENBQVY7QUFDQSxNQUFNVSxVQUFVVixRQUFRLFVBQVIsQ0FBaEI7O0FBRUEsTUFBTVcsV0FBV1gsUUFBUSxXQUFSLENBQWpCO0FBQ0EsTUFBTVksaUJBQWlCWixRQUFRLHlCQUFSLENBQXZCOztBQUVBLE1BQU1hLEtBQU4sQ0FBWTtBQUNWQyxjQUFZQyxTQUFTLEVBQXJCLEVBQXlCO0FBQ3ZCZCxVQUFNLGtCQUFOLEVBQTBCYyxNQUExQjs7QUFFQTtBQUNBLFFBQUlBLE9BQU9DLFlBQVgsRUFBeUI7QUFDdkJELGFBQU9ILGNBQVAsR0FBd0JHLE9BQU9DLFlBQS9CO0FBQ0EsYUFBT0QsT0FBT0MsWUFBZDtBQUNEO0FBQ0QsUUFBSUQsT0FBT0UsWUFBWCxFQUF5QjtBQUN2QkYsYUFBT0csS0FBUCxHQUFlLEtBQWY7QUFDQSxhQUFPSCxPQUFPRSxZQUFkO0FBQ0Q7O0FBRUQs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QU0sT0FBSy9DLE1BQUwsQ0FBWTZCLFNBQVosQ0FBc0JFLFFBQXRCLENBQStCakIsT0FBL0IsQ0FBbEI7QUFDQTVCLGdCQUFNLGNBQU47QUFDQXFCLGtCQUFRd0MsR0FBUjtBQUNELFNBeEJELENBd0JFLE9BQU9QLEdBQVAsRUFBWTtBQUNaSixpQkFBT0ksR0FBUDtBQUNEO0FBQ0YsT0E1Qk07O0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FBUDtBQTZCRDtBQXhSUzs7QUEyUlpzQyxPQUFPQyxPQUFQLEdBQWlCakYsS0FBakIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbWFpbC10ZW1wbGF0ZXMnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbmNvbnN0IGh0bWxUb1RleHQgPSByZXF1aXJlKCdodG1sLXRvLXRleHQnKTtcbmNvbnN0IEkxOE4gPSByZXF1aXJlKCdAbGFkanMvaTE4bicpO1xuY29uc3QgYXV0b0JpbmQgPSByZXF1aXJlKCdhdXRvLWJpbmQnKTtcbmNvbnN0IG5vZGVtYWlsZXIgPSByZXF1aXJlKCdub2RlbWFpbGVyJyk7XG5jb25zdCBjb25zb2xpZGF0ZSA9IHJlcXVpcmUoJ2NvbnNvbGlkYXRlJyk7XG5jb25zdCBwcmV2aWV3RW1haWwgPSByZXF1aXJlKCdwcmV2aWV3LWVtYWlsJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxuY29uc3QgZ2V0UGF0aHMgPSByZXF1aXJlKCdnZXQtcGF0aHMnKTtcbmNvbnN0IGp1aWNlUmVzb3VyY2VzID0gcmVxdWlyZSgnanVpY2UtcmVzb3VyY2VzLXByb21pc2UnKTtcblxuY2xhc3MgRW1haWwge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIGRlYnVnKCdjb25maWcgcGFzc2VkICVPJywgY29uZmlnKTtcblxuICAgIC8vIDIueCBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdXBwb3J0XG4gICAgaWYgKGNvbmZpZy5qdWljZU9wdGlvbnMpIHtcbiAgICAgIGNvbmZpZy5qdWljZVJlc291cmNlcyA9IGNvbmZpZy5qdWljZU9wdGlvbnM7XG4gICAgICBkZWxldGUgY29uZmlnLmp1aWNlT3B0aW9ucztcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5kaXNhYmxlSnVpY2UpIHtcbiAgICAgIGNvbmZpZy5qdWljZSA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNvbmZpZy5kaXNhYmxlSnVpY2U7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcgPSBfLm1lcmdlKFxuICAgICAge1xuICAgICAgICB2aWV3czoge1xuICAgICAgICAgIC8vIGRpcmVjdG9yeSB3aGVyZSBlbWFpbCB0ZW1wbGF0ZXMgcmVzaWRlXG4gICAgICAgICAgcm9vdDogcGF0aC5yZXNvbHZlKCdlbWFpbHMnKSxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IGZpbGUgZXh0ZW5zaW9uIGZvciB0ZW1wbGF0ZVxuICAgICAgICAgICAgZXh0ZW5zaW9uOiAncHVnJyxcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICBlbmdpbmVTb3VyY2U6IGNvbnNvbGlkYXRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBsb2NhbHMgdG8gcGFzcyB0byB0ZW1wbGF0ZXMgZm9yIHJlbmRlcmluZ1xuICAgICAgICAgIGxvY2Fsczoge1xuICAgICAgICAgICAgLy8gcHJldHR5IGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBmYWxzZWAgZm9yIHN1YmplY3QvdGV4dFxuICAgICAgICAgICAgcHJldHR5OiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyA8aHR0cHM6Ly9ub2RlbWFpbGVyLmNvbS9tZXNzYWdlLz5cbiAgICAgICAgbWVzc2FnZToge30sXG4gICAgICAgIHNlbmQ6ICFbJ2RldmVsb3BtZW50JywgJ3Rlc3QnXS5pbmNsdWRlcyhwcm9jZXNzLmVudi5OT0RFX0VOViksXG4gICAgICAgIHByZXZpZXc6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxuICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2xhZGpzL2kxOG4+XG4gICAgICAgIC8vIHNldCB0byBhbiBvYmplY3QgdG8gY29uZmlndXJlIGFuZCBlbmFibGUgaXRcbiAgICAgICAgaTE4bjogZmFsc2UsXG4gICAgICAgIC8vIHBhc3MgYSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uIGlmIG5lY2Vzc2FyeVxuICAgICAgICByZW5kZXI6IHRoaXMucmVuZGVyLmJpbmQodGhpcyksXG4gICAgICAgIC8vIGZvcmNlIHRleHQtb25seSByZW5kZXJpbmcgb2YgdGVtcGxhdGUgKGRpc3JlZ2FyZHMgdGVtcGxhdGUgZm9sZGVyKVxuICAgICAgICB0ZXh0T25seTogZmFsc2UsXG4gICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vd2Vyazg1L25vZGUtaHRtbC10by10ZXh0PlxuICAgICAgICBodG1sVG9UZXh0OiB7XG4gICAgICAgICAgaWdub3JlSW1hZ2U6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2p1aWNlPlxuICAgICAgICBqdWljZTogdHJ1ZSxcbiAgICAgICAganVpY2VSZXNvdXJjZXM6IHtcbiAgICAgICAgICBwcmVzZXJ2ZUltcG9ydGFudDogdHJ1ZSxcbiAgICAgICAgICB3ZWJSZXNvdXJjZXM6IHtcbiAgICAgICAgICAgIHJlbGF0aXZlVG86IHBhdGgucmVzb2x2ZSgnYnVpbGQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gcGFzcyBhIHRyYW5zcG9ydCBjb25maWd1cmF0aW9uIG9iamVjdCBvciBhIHRyYW5zcG9ydCBpbnN0YW5jZVxuICAgICAgICAvLyAoZS5nLiBhbiBpbnN0YW5jZSBpcyBjcmVhdGVkIHZpYSBgbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnRgKVxuICAgICAgICAvLyA8aHR0cHM6Ly9ub2RlbWFpbGVyLmNvbS90cmFuc3BvcnRzLz5cbiAgICAgICAgdHJhbnNwb3J0OiB7fVxuICAgICAgfSxcbiAgICAgIGNvbmZpZ1xuICAgICk7XG5cbiAgICAvLyBvdmVycmlkZSBleGlzdGluZyBtZXRob2RcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMuY29uZmlnLnJlbmRlcjtcblxuICAgIGlmICghXy5pc0Z1bmN0aW9uKHRoaXMuY29uZmlnLnRyYW5zcG9ydC5zZW5kTWFpbCkpXG4gICAgICB0aGlzLmNvbmZpZy50cmFuc3BvcnQgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydCh0aGlzLmNvbmZpZy50cmFuc3BvcnQpO1xuXG4gICAgZGVidWcoJ3RyYW5zZm9ybWVkIGNvbmZpZyAlTycsIHRoaXMuY29uZmlnKTtcblxuICAgIGF1dG9CaW5kKHRoaXMpO1xuICB9XG5cbiAgLy8gc2hvcnRoYW5kIHVzZSBvZiBganVpY2VSZXNvdXJjZXNgIHdpdGggdGhlIGNvbmZpZ1xuICAvLyAobWFpbmx5IGZvciBjdXN0b20gcmVuZGVycyBsaWtlIGZyb20gYSBkYXRhYmFzZSlcbiAganVpY2VSZXNvdXJjZXMoaHRtbCkge1xuICAgIHJldHVybiBqdWljZVJlc291cmNlcyhodG1sLCB0aGlzLmNvbmZpZy5qdWljZVJlc291cmNlcyk7XG4gIH1cblxuICAvLyBhIHNpbXBsZSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhY3R1YWwgZmlsZSBwYXRoIGZvciB0aGUgdGVtcGxhdGVcbiAgZ2V0VGVtcGxhdGVQYXRoKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBhd2FpdCBnZXRQYXRocyhcbiAgICAgICAgICB0aGlzLmNvbmZpZy52aWV3cy5yb290LFxuICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgdGhpcy5jb25maWcudmlld3Mub3B0aW9ucy5leHRlbnNpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5jb25maWcudmlld3Mucm9vdCwgcGF0aHMucmVsKTtcbiAgICAgICAgcmVzb2x2ZSh7IGZpbGVQYXRoLCBwYXRocyB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBhIHRlbXBsYXRlIGV4aXN0c1xuICAvLyAodXNlcyBzYW1lIGxvb2stdXAgYXBwcm9hY2ggYXMgYHJlbmRlcmAgZnVuY3Rpb24pXG4gIHRlbXBsYXRlRXhpc3RzKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgcmVzb2x2ZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGZpbGVQYXRoIH0gPSBhd2FpdCB0aGlzLmdldFRlbXBsYXRlUGF0aCh2aWV3KTtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5zdGF0KGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKCFzdGF0cy5pc0ZpbGUoKSkgdGhyb3cgbmV3IEVycm9yKGAke2ZpbGVQYXRofSB3YXMgbm90IGEgZmlsZWApO1xuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCd0ZW1wbGF0ZUV4aXN0cycsIGVycik7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gcHJvbWlzZSB2ZXJzaW9uIG9mIGNvbnNvbGlkYXRlJ3MgcmVuZGVyXG4gIC8vIGluc3BpcmVkIGJ5IGtvYS12aWV3cyBhbmQgcmUtdXNlcyB0aGUgc2FtZSBjb25maWdcbiAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9xdWVja2V6ei9rb2Etdmlld3M+XG4gIHJlbmRlcih2aWV3LCBsb2NhbHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IG1hcCwgZW5naW5lU291cmNlIH0gPSB0aGlzLmNvbmZpZy52aWV3cy5vcHRpb25zO1xuICAgICAgICBjb25zdCB7IGZpbGVQYXRoLCBwYXRocyB9ID0gYXdhaXQgdGhpcy5nZXRUZW1wbGF0ZVBhdGgodmlldyk7XG4gICAgICAgIGlmIChwYXRocy5leHQgPT09ICdodG1sJyAmJiAhbWFwKSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGVuZ2luZU5hbWUgPSBtYXAgJiYgbWFwW3BhdGhzLmV4dF0gPyBtYXBbcGF0aHMuZXh0XSA6IHBhdGhzLmV4dDtcbiAgICAgICAgICBjb25zdCByZW5kZXJGbiA9IGVuZ2luZVNvdXJjZVtlbmdpbmVOYW1lXTtcbiAgICAgICAgICBpZiAoIWVuZ2luZU5hbWUgfHwgIXJlbmRlckZuKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBFbmdpbmUgbm90IGZvdW5kIGZvciB0aGUgXCIuJHtwYXRocy5leHR9XCIgZmlsZSBleHRlbnNpb25gXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoXy5pc09iamVjdCh0aGlzLmNvbmZpZy5pMThuKSkge1xuICAgICAgICAgICAgY29uc3QgaTE4biA9IG5ldyBJMThOKFxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZy5pMThuLCB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXI6IGxvY2Fsc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gc3VwcG9ydCBgbG9jYWxzLnVzZXIubGFzdF9sb2NhbGVgXG4gICAgICAgICAgICAvLyAoZS5nLiBmb3IgPGh0dHBzOi8vbGFkLmpzLm9yZz4pXG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChsb2NhbHMudXNlcikgJiYgXy5pc1N0cmluZyhsb2NhbHMudXNlci5sYXN0X2xvY2FsZSkpXG4gICAgICAgICAgICAgIGxvY2Fscy5sb2NhbGUgPSBsb2NhbHMudXNlci5sYXN0X2xvY2FsZTtcblxuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcobG9jYWxzLmxvY2FsZSkpIGkxOG4uc2V0TG9jYWxlKGxvY2Fscy5sb2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IGNvbnZlcnQgdGhpcyB0byBhIHByb21pc2UgYmFzZWQgdmVyc2lvblxuICAgICAgICAgIHJlbmRlckZuKGZpbGVQYXRoLCBsb2NhbHMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRoZSBodG1sIHdpdGgganVpY2UgdXNpbmcgcmVtb3RlIHBhdGhzXG4gICAgICAgICAgICAvLyBnb29nbGUgbm93IHN1cHBvcnRzIG1lZGlhIHF1ZXJpZXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2dtYWlsL2Rlc2lnbi9yZWZlcmVuY2Uvc3VwcG9ydGVkX2Nzc1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5qdWljZSkgcmV0dXJuIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIHRoaXMuanVpY2VSZXNvdXJjZXMocmVzKVxuICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyQWxsKHRlbXBsYXRlLCBsb2NhbHMgPSB7fSwgbWVzc2FnZSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzdWJqZWN0VGVtcGxhdGVFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGh0bWxUZW1wbGF0ZUV4aXN0cyA9IGZhbHNlO1xuICAgICAgICBsZXQgdGV4dFRlbXBsYXRlRXhpc3RzID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZUV4aXN0cyhgJHt0ZW1wbGF0ZX0vc3ViamVjdGApLFxuICAgICAgICAgIHRoaXMudGVtcGxhdGVFeGlzdHMoYCR7dGVtcGxhdGV9L2h0bWxgKSxcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlRXhpc3RzKGAke3RlbXBsYXRlfS90ZXh0YClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAodGVtcGxhdGUpXG4gICAgICAgICAgW1xuICAgICAgICAgICAgc3ViamVjdFRlbXBsYXRlRXhpc3RzLFxuICAgICAgICAgICAgaHRtbFRlbXBsYXRlRXhpc3RzLFxuICAgICAgICAgICAgdGV4dFRlbXBsYXRlRXhpc3RzXG4gICAgICAgICAgXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBpZiAoIW1lc3NhZ2Uuc3ViamVjdCAmJiBzdWJqZWN0VGVtcGxhdGVFeGlzdHMpXG4gICAgICAgICAgbWVzc2FnZS5zdWJqZWN0ID0gYXdhaXQgdGhpcy5yZW5kZXIoXG4gICAgICAgICAgICBgJHt0ZW1wbGF0ZX0vc3ViamVjdGAsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBsb2NhbHMsIHsgcHJldHR5OiBmYWxzZSB9KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFtZXNzYWdlLmh0bWwgJiYgaHRtbFRlbXBsYXRlRXhpc3RzKVxuICAgICAgICAgIG1lc3NhZ2UuaHRtbCA9IGF3YWl0IHRoaXMucmVuZGVyKGAke3RlbXBsYXRlfS9odG1sYCwgbG9jYWxzKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgKCFodG1sVGVtcGxhdGVFeGlzdHMgfHwgIXRoaXMuY29uZmlnLmh0bWxUb1RleHQpICYmXG4gICAgICAgICAgIW1lc3NhZ2UudGV4dCAmJlxuICAgICAgICAgIHRleHRUZW1wbGF0ZUV4aXN0c1xuICAgICAgICApXG4gICAgICAgICAgbWVzc2FnZS50ZXh0ID0gYXdhaXQgdGhpcy5yZW5kZXIoXG4gICAgICAgICAgICBgJHt0ZW1wbGF0ZX0vdGV4dGAsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBsb2NhbHMsIHsgcHJldHR5OiBmYWxzZSB9KVxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLmh0bWxUb1RleHQgJiYgbWVzc2FnZS5odG1sKVxuICAgICAgICAgIC8vIHdlJ2QgdXNlIG5vZGVtYWlsZXItaHRtbC10by10ZXh0IHBsdWdpblxuICAgICAgICAgIC8vIGJ1dCB3ZSByZWFsbHkgZG9uJ3QgbmVlZCB0byBzdXBwb3J0IGNpZFxuICAgICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vYW5kcmlzOS9ub2RlbWFpbGVyLWh0bWwtdG8tdGV4dD5cbiAgICAgICAgICBtZXNzYWdlLnRleHQgPSBodG1sVG9UZXh0LmZyb21TdHJpbmcoXG4gICAgICAgICAgICBtZXNzYWdlLmh0bWwsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5odG1sVG9UZXh0XG4gICAgICAgICAgKTtcblxuICAgICAgICAvLyBpZiB3ZSBvbmx5IHdhbnQgYSB0ZXh0LWJhc2VkIHZlcnNpb24gb2YgdGhlIGVtYWlsXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy50ZXh0T25seSkgZGVsZXRlIG1lc3NhZ2UuaHRtbDtcblxuICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2VuZChvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgdGVtcGxhdGU6ICcnLFxuICAgICAgICBtZXNzYWdlOiB7fSxcbiAgICAgICAgbG9jYWxzOiB7fVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgbGV0IHsgdGVtcGxhdGUsIG1lc3NhZ2UsIGxvY2FscyB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGF0dGFjaG1lbnRzID1cbiAgICAgIG1lc3NhZ2UuYXR0YWNobWVudHMgfHwgdGhpcy5jb25maWcubWVzc2FnZS5hdHRhY2htZW50cyB8fCBbXTtcblxuICAgIG1lc3NhZ2UgPSBfLmRlZmF1bHRzRGVlcChcbiAgICAgIHt9LFxuICAgICAgXy5vbWl0KHRoaXMuY29uZmlnLm1lc3NhZ2UsICdhdHRhY2htZW50cycpLFxuICAgICAgXy5vbWl0KG1lc3NhZ2UsICdhdHRhY2htZW50cycpXG4gICAgKTtcbiAgICBsb2NhbHMgPSBfLmRlZmF1bHRzRGVlcCh7fSwgdGhpcy5jb25maWcudmlld3MubG9jYWxzLCBsb2NhbHMpO1xuXG4gICAgaWYgKGF0dGFjaG1lbnRzKSBtZXNzYWdlLmF0dGFjaG1lbnRzID0gYXR0YWNobWVudHM7XG5cbiAgICBkZWJ1ZygndGVtcGxhdGUgJXMnLCB0ZW1wbGF0ZSk7XG4gICAgZGVidWcoJ21lc3NhZ2UgJU8nLCBtZXNzYWdlKTtcbiAgICBkZWJ1ZygnbG9jYWxzIChrZXlzIG9ubHkpOiAlTycsIE9iamVjdC5rZXlzKGxvY2FscykpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGdldCBhbGwgYXZhaWxhYmxlIHRlbXBsYXRlc1xuICAgICAgICBjb25zdCBvYmogPSBhd2FpdCB0aGlzLnJlbmRlckFsbCh0ZW1wbGF0ZSwgbG9jYWxzLCBtZXNzYWdlKTtcblxuICAgICAgICAvLyBhc3NpZ24gdGhlIG9iamVjdCB2YXJpYWJsZXMgb3ZlciB0byB0aGUgbWVzc2FnZVxuICAgICAgICBPYmplY3QuYXNzaWduKG1lc3NhZ2UsIG9iaik7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnByZXZpZXcpIHtcbiAgICAgICAgICBkZWJ1ZygndXNpbmcgYHByZXZpZXctZW1haWxgIHRvIHByZXZpZXcgZW1haWwnKTtcbiAgICAgICAgICBhd2FpdCBwcmV2aWV3RW1haWwobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnNlbmQpIHtcbiAgICAgICAgICBkZWJ1Zygnc2VuZCBkaXNhYmxlZCBzbyB3ZSBhcmUgZW5zdXJpbmcgSlNPTlRyYW5zcG9ydCcpO1xuICAgICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vbm9kZW1haWxlci9ub2RlbWFpbGVyL2lzc3Vlcy83OTg+XG4gICAgICAgICAgLy8gaWYgKHRoaXMuY29uZmlnLnRyYW5zcG9ydC5uYW1lICE9PSAnSlNPTlRyYW5zcG9ydCcpXG4gICAgICAgICAgdGhpcy5jb25maWcudHJhbnNwb3J0ID0gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQoe1xuICAgICAgICAgICAganNvblRyYW5zcG9ydDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jb25maWcudHJhbnNwb3J0LnNlbmRNYWlsKG1lc3NhZ2UpO1xuICAgICAgICBkZWJ1ZygnbWVzc2FnZSBzZW50Jyk7XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVtYWlsO1xuIl19